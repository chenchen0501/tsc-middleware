---
description: FastAPI 接口设计和最佳实践
---

# FastAPI 接口设计规范

## ⚠️ 重要：API 文档同步规范

**强制要求：只要对接口进行调整，必须同时更新 [API.md](mdc:API.md) 文档！**

### 需要更新文档的情况

1. **新增接口**：添加完整的接口说明、请求/响应示例
2. **修改接口**：更新参数说明、请求体结构、响应格式
3. **删除接口**：从文档中移除或标记为已废弃
4. **修改参数**：更新参数类型、验证规则、默认值
5. **修改响应**：更新响应格式、状态码、错误信息

### 文档更新检查清单

在修改 [main.py](mdc:main.py) 中的接口后，确保完成：

- [ ] 更新接口路径和方法（GET/POST）
- [ ] 更新请求参数说明和示例
- [ ] 更新响应格式和示例
- [ ] 更新错误码和错误信息
- [ ] 添加使用示例（curl 命令）
- [ ] 更新版本号和更新日期（如有）

### 文档更新示例

当在 [main.py](mdc:main.py) 中添加新接口：

```python
@app.post("/print/barcode")
def api_print_barcode(job: BarcodeJob):
    """仅打印条形码（无文本）"""
    pass
```

必须同时在 [API.md](mdc:API.md) 中添加：

```markdown
## POST /print/barcode

仅打印条形码（无文本）

### 请求体

\`\`\`json
{
"barcode": "1234567890",
"type": "128",
"qty": 1
}
\`\`\`

### 响应

\`\`\`json
{
"status": "ok",
"message": "成功发送 1 张条形码到 USB 打印机"
}
\`\`\`
```

### 文档一致性原则

- 代码是真理，文档必须与代码保持一致
- 先修改代码，立即更新文档（不要拖延）
- 文档应该包含实际可用的请求示例
- 参数说明应该与 Pydantic 模型完全对应

## API 响应格式标准

### 成功响应

```json
{
  "status": "ok",
  "message": "操作成功的描述信息"
}
```

### 错误响应

```json
{
  "detail": "错误的详细信息"
}
```

## HTTP 状态码使用规范

- **200 OK**: 操作成功
- **400 Bad Request**: 客户端参数错误（验证失败）
- **500 Internal Server Error**: 服务器内部错误（打印失败等）
- **503 Service Unavailable**: 服务不可用（打印机连接失败）

## Pydantic 模型定义规范

### 模型命名

- 请求模型: `*Job` (如 `PrintJob`, `QRCodeJob`)
- 响应模型: `*Response` (如需要定义的话)

### Field 定义示例

```python
class PrintJob(BaseModel):
    """打印任务模型（USB模式，纸张区域10cm×8cm）"""
    text: str = Field(
        ...,  # 必填字段
        description="标签文本",
        json_schema_extra={"example": "Hello TSC USB"}
    )
    qty: int = Field(
        1,  # 默认值
        ge=1,  # 最小值
        le=100,  # 最大值
        description="打印数量"
    )
```

### 类型提示

- 使用 Python 3.10+ 原生类型：`list[str]`, `dict[str, int]`
- 不要使用 `typing.List`, `typing.Dict`（已过时）

## 路由定义规范

### 路由装饰器

```python
@app.post("/print")
def api_print(job: PrintJob):
    """
    打印标签（USB模式）

    - **text**: 标签上的文本内容
    - **barcode**: 条形码数据（可选）
    - **qty**: 打印数量（1-100）
    """
```

### 错误处理模式

```python
try:
    # 业务逻辑
    print_label(...)
    return {"status": "ok", "message": "成功"}
except Exception as e:
    raise HTTPException(
        status_code=500,
        detail=f"打印失败: {str(e)}"
    )
```

## 现有 API 端点

参考 [main.py](mdc:main.py)：

1. **GET /** - 服务信息
2. **GET /health** - 健康检查
3. **POST /print** - 打印文本和条形码
4. **POST /print/qrcode** - 打印二维码
5. **POST /print/batch** - 批量打印
6. **POST /test** - 测试连接

## 新增 API 端点建议

### 命名规范

- 使用小写字母和连字符
- 使用 RESTful 风格
- 同类功能放在同一前缀下（如 `/print/*`）

### 示例：添加新端点

```python
@app.post("/print/barcode")
def api_print_barcode(job: BarcodeJob):
    """
    仅打印条形码（无文本）

    - **barcode**: 条形码数据
    - **type**: 条形码类型（128, 39, EAN13等）
    - **qty**: 打印数量
    """
    try:
        # 实现打印逻辑
        return {"status": "ok", "message": "打印成功"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

## 参数验证

### 使用 Pydantic 验证器

```python
from pydantic import field_validator

class PrintJob(BaseModel):
    ip: str

    @field_validator('ip')
    @classmethod
    def validate_ip(cls, v):
        # 自定义验证逻辑
        return v
```

### 使用 Field 约束

```python
qty: int = Field(1, ge=1, le=100)  # 1-100 之间
width: str = Field("100", pattern=r"^\d+$")  # 纯数字字符串
```

## API 文档优化

### OpenAPI 元数据配置

参考 [main.py](mdc:main.py) 中的 FastAPI 初始化：

```python
app = FastAPI(
    title="TSC-Print-Service",
    version="2.0.0",
    description="零驱动USB打印中间件 | macOS开发 ➜ Windows部署"
)
```

### 路由分组（可选）

对于大型项目，可以使用 APIRouter：

```python
from fastapi import APIRouter

router = APIRouter(prefix="/print", tags=["打印"])

@router.post("/")
def print_label(...):
    pass

app.include_router(router)
```

## 测试建议

### 使用 FastAPI TestClient

```python
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_health():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "alive"
```

### 使用 pytest

```bash
pip install pytest httpx
pytest test_api.py
```

## 性能优化

### 异步端点（可选）

如果有 I/O 密集操作，考虑使用异步：

```python
@app.post("/print")
async def api_print(job: PrintJob):
    # 使用 asyncio
    pass
```

注意：tsclib 当前是同步的，不适合异步操作。

### 并发控制

打印操作是串行的，避免并发打印导致问题：

- 可以添加队列机制
- 或使用 API 限流（如 slowapi）
